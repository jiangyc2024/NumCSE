% ncse_new/p1_SystemsOfEquations/ch3_IterativeMethodsNonLinear/ex_ModifiedNewton.tex
% the exercise requires:   -
% the solutions require:   ModNewtOrder.m  ModNewtStep.m  ModNewtSys.m  ModNewtOrder.eps
\renewcommand{\chpt}{ch_iterativenlse}

\begin{problem}[Modified Newton method \coreproblem] \label{prb:ModifiedNewton}

The following problem consists in \Eigen{} implementation of a modified version of the Newton method (in one dimension \ncsesect{sec:newton-verfahren-1d} and many dimensions \ncsesect{sec:Newton}) for the solution of a nonlinear system. Refresh yourself on stopping criteria for iterative methods \ncsesect{sec:termination-criteria-1}.

For the solution of the non-linear system of equations $\VF(\Vx) = \Vzero$ (with $\VF:\IR^n\rightarrow\IR^n$), the following iterative method can be used:
\begin{equation}  \label{eq:ABB10}
\begin{aligned}
\Vy^{(k)}   & = \Vx^{(k)} + D\VF(\Vx^{(k)})^{-1}\;\VF(\Vx^{(k)})\;,\\
\Vx^{(k+1)} & = \Vy^{(k)} - D\VF(\Vx^{(k)})^{-1}\;\VF(\Vy^{(k)})\;,
\end{aligned}
\end{equation}
where $D\VF(\Vx)\in\bbR^{n,n}$ is the Jacobian matrix of $\VF$ evaluated in the point $\Vx$.

%%%%%%%%%%%% SUBPROBLEM 1
\begin{subproblem}[2] \label{subprb:ModifiedNewton_1} Show that the iteration
  \eqref{eq:ABB10} is consistent with {$\VF(\Vx)=\Vzero$} in the sense of
  \lref{def:consitfp}, that is, show that $\Vx^{(k)} = \Vx^{(0)}$ for every $k\in\IN$, if and only if
  $\VF(\Vx^{(0)}) = \Vzero$ and $D\VF(\Vx^{(0)})$ is regular.

%%% 12.7 old version, prove consistency with IFF:
% Show that \eqref{eq:ABB10} provides a fixed point iteration that is consistent with $\VF(\Vx)=\Vzero$, provided that $D\VF$ is regular everywhere and $\VF$ is injective (i.e., $\VF(\Vx)=\VF(\Vy)\Leftrightarrow\Vx=\Vy$).
% 
% \hint: refer to Def.~4.2.1 from the course notes and use a slight generalization of it.
% 
% \andrea{added annoying hypothesis to match with slides def., they are supposed to show iff, more complicated }

\begin{solution}
If $\VF(\Vx^{(k)})=\Vzero$ then $\Vy^{(k)}=\Vx^{(k)}+\Vzero=\Vx^{(k)}$ and $\Vx^{(k+1)}=\Vy^{(k)}-\Vzero=\Vx^{(k)}$.\\
So, by induction, if $\VF(\Vx^{(0)})=\Vzero$ then $\Vx^{(k+1)}=\Vx^{(k)}=\Vx^{(0)}$ for every $k$.

Conversely, if $\vec{x}^{(k+1)} = \vec{x}^{(k)}$, then, by the recursion of the Newton method:
\begin{align*}
 \vec{F}(x^{(k)}) = \vec{F}(x^{(k)} + D\VF(\Vx^{(k)})^{-1}\;\VF(\Vx^{(k)})) \\
 \Rightarrow D\VF(\Vx^{(k)})^{-1}\;\VF(\Vx^{(k)}) = 0 \\
 \Rightarrow \VF(\Vx^{(k)}) = 0
\end{align*}
\end{solution}
\end{subproblem}

%%%%%%%%%%%% SUBPROBLEM 2
\begin{subproblem}[3] \label{subprb:ModifiedNewton_2}
Implement a \Cpp{} function
\begin{lstlisting}        
template <typename arg, class func, class jac>
void mod_newt_step(const arg & x, arg & x_next,
		   func&& f, jac&& df);
\end{lstlisting}
that computes a step of the method \eqref{eq:ABB10} for a \emph{scalar} function $\VF$, that is, for the case $n=1$. 

Here, \texttt{f} is a lambda function for the function $F:\bbR\mapsto\bbR$ and \texttt{df} a lambda to its derivative $F':\bbR\mapsto\bbR$.
\begin{hint}
Your lambda functions will likely be:
\begin{lstlisting}
auto f = [ /* captured vars. */ ] (double x)
	 { /* fun. body */ }; 
auto df = [ /* captured vars. */ ] (double x)
	  { /* fun. body */ }; 
\end{lstlisting}
Notice that here \verb|auto| is \verb|std::function<double(double)>|.
\end{hint}

\begin{hint}
 Have a look at:
  \begin{itemize}
   \item \href{http://en.cppreference.com/w/cpp/language/lambda}{http://en.cppreference.com/w/cpp/language/lambda}
   \item \href{https://msdn.microsoft.com/en-us/library/dd293608.aspx}{https://msdn.microsoft.com/en-us/library/dd293608.aspx}
  \end{itemize}
  for more information on lambda functions.
\end{hint}


\cprotEnv \begin{solution}
  See \verb|modnewt.cpp| and \verb|general_nonlinear_solver.h|.
% \lstinputlisting[caption={implementation for the function \texttt{ModNewtStep}},label={mc:StructuredMatrixVector_ModNewtStep}]
% {p1_SystemsOfEquations/ch3_IterativeMethodsNonLinear/MATLAB/ModNewtStep.m}
\end{solution}
\end{subproblem}

%%%%%%%%%%%% SUBPROBLEM 3

\begin{subproblem}[2] \label{subprb:ModifiedNewton_3}
What is the order of convergence of the method?\\
To investigate it, write a \Cpp function \verb|void mod_newt_ord()|
that:
\begin{itemize}
\item uses the function \verb|mod_newt_step| from subtask~\ref{subprb:ModifiedNewton_2} in order to apply \eqref{eq:ABB10} to the following scalar equation 
  $$\operatorname{arctan}(x) - 0.123 = 0\;;$$
\item determines empirically the order of convergence% of the method
  , in the sense of \ncserem{rem:eoc} of the course slides;
\item implements meaningful stopping criteria (\ncsesect{sec:termination-criteria-1}).
\end{itemize}
Use $x_0=5$ as initial guess.
\vspace{1.5ex}

\begin{hint}
  the exact solution is \; $x=\tan(a)=0.123624065869274\dots$\\
\end{hint}
\begin{hint}
  remember that \; $\operatorname{arctan}'(x)=\frac1{1+x^2}$.%=1/(1+x^2)$.
\end{hint}

\cprotEnv \begin{solution}
See \verb|modnewt.cpp| and \verb|general_nonlinear_solver.h|.
The order of convergence is approximately 3:\\
\begin{center}
\begin{tabular}{lll}
           sol. &          err.  &         order \\
              5 &       4.87638 & \\
       0.560692 &       4.87638 & \\
       0.155197 &      0.437068 & \\
       0.123644 &    0.0315725   &     1.08944 \\
       0.123624 &  2.00333e-05   &     2.80183 \\
       0.123624 &   5.19029e-15   &     2.99809 \\
\end{tabular}
\end{center}

% \lstinputlisting[caption={implementation for the function \texttt{ModNewtOrder}}]
% {p1_SystemsOfEquations/ch3_IterativeMethodsNonLinear/MATLAB/ModNewtOrder.m}
% \begin{figure}
% \centering
% % \includegraphics[width=0.6\textwidth]{p1_SystemsOfEquations/ch3_IterativeMethodsNonLinear/PICTURES/ModNewtOrder}
% \caption{Convergence of the modified Newton method.}
% \label{fig:ModifiedNewton_ModNewtOrder}
% \end{figure}
\end{solution}
\end{subproblem}

%%%%%%%%%%%% SUBPROBLEM 4
\begin{subproblem}[4] \label{subprb:ModifiedNewton_4}
Write a \Cpp{} function \verb|void mod_newt_sys()|
that provides an efficient implementation of the method \eqref{eq:ABB10} for the non-linear system
\begin{equation*}
  \VF(\Vx) := \VA\Vx +  \begin{pmatrix}   c_{1}e^{x_{1}} \\   \vdots  \\    c_{n}e^{x_{n}} \end{pmatrix} = \Vzero \;,
\end{equation*}
where $\VA\in\bbR^{n,n}$ is symmetric positive definite, and $c_{i}\ge0$,
$i=1,\ldots,n$. Stop the iteration when the Euclidean norm of the increment
$\Vx^{(k+1)}-\Vx^{(k)}$ relative to the norm of $\Vx^{(k+1)}$ is smaller than the
tolerance passed in \texttt{tol}.
Use the zero vector as initial guess.

% Provide an efficient \Matlab implementation of the iteration~\eqref{eq:ABB10} for the non-linear system
% \begin{equation*}
% \VF(\Vx) := \VA\Vx +  \begin{pmatrix}   c_{1}e^{x_{1}} \\   \vdots  \\    c_{n}e^{x_{n}} \end{pmatrix} = \Vzero \;,
% \end{equation*}
% where $\VA\in\bbR^{n,n}$ is tridiagonal s.p.d., $c_{i}>0$, $i=1,\ldots,n$, in the function
% \begin{center}        \texttt{x = ModNewtSys( A, c )}\;.    \end{center}
\begin{hint}
 You can proceed as in the previous task: define function handles as lambda functions and create a ``stepping'' function, which you the iterate inside a for loop.
\end{hint}

\begin{hint}
 Try and be as efficient as possible. Reuse the matrix factorization when possible.
\end{hint}

\cprotEnv \begin{solution}
See \verb|modnewt.cpp| and \verb|general_nonlinear_solver.h|.
% Code:
% \lstinputlisting[caption={implementation for the function \texttt{ModNewtSys}},escapechar={}]
% {p1_SystemsOfEquations/ch3_IterativeMethodsNonLinear/MATLAB/ModNewtSys.m}
% Even better with only one LU decomposition for the solution of the 2 linear systems.
\end{solution}
\end{subproblem}

%%%%%%%%%%%% SUBPROBLEM 5
% \begin{subproblem}[3] \label{subprb:ModifiedNewton_5}
% In order to apply the iteration~\eqref{eq:ABB10}, two linear systems have to be solved.
% %In both cases the system matrix is the Jacobian $D\VF$ evaluated in $\Vx^{(k)}$.
% What do these systems have in common?  How can this fact be used to speed up an implementation of the method for large $n$?
% 
% \begin{solution}
% The two systems share the same matrix $D\VF(\Vx^{(k)})$.
% The LU decomposition of the matrix $D\VF(\Vx^{(k)})$ can be computed once and used twice in order to solve both linear systems.
% The computation of the LU decomposition is more expensive ($O(n^3)$) than the solution of the two triangular systems ($O(n^2)$).
% \end{solution}
% \end{subproblem}

\end{problem}
