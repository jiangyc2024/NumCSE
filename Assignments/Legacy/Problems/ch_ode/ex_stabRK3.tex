\begin{problem}[Stability of a Runge-Kutta Method \coreproblem] \label{prb:stabRK3} 

We consider a 3-stage Runge--Kutta single step method described by the Butcher-Tableau
\begin{align} \label{eq:rkesv}
\begin{array}{c|ccc}
    0   & 0   & 0   & 0   \\
    1   & 1   & 0   & 0   \\
    1/2 & 1/4 & 1/4 & 0   \\\hline
    & 1/6 & 1/6 & 2/3 \\
\end{array}
\end{align}

% \begin{subproblem}[1]
% Implement the Runge--Kutta single-step method for the general initial value problem 
%   \begin{equation*}
%     \dot{\Vy}(t) = f(\Vy(t)), \quad \Vy(t_0) = \Vy_0.
%   \end{equation*}
% 
% 
% 
% \cprotEnv \begin{solution}
% See \verb|stabrk|.
% % \lstinputlisting[ 
% % 		emph={}, 
% % 		caption={Implementation of \texttt{RK3Solve.m}},
% % 		label={code:RK3Solve}
% % 		]{matlab/RK3Solve.m}
% \end{solution}
% 
% \end{subproblem}

\begin{subproblem}[1]
Consider the prey/predator model
\begin{align} \label{eq:predator-prey}
 \dot y_1(t) = (1 - y_2(t)) y_1(t) \\
 \dot y_2(t) = (y_1(t) - 1) y_2(t) \\
 \vec{y}(0) = \left[ 100, 1 \right].
\end{align}
Write a \Cpp{} code to approximate the solution up to time $T = 1$ of the IVP. Use a RK-SSM defined above. Numerically determine the convergence order of the method for uniform steps of size $2^{-j}, j = 2,\dots,13$.
	
Use, as a reference solution, an approximation with $2^{14}$ steps.

What do you notice for big step sizes? What is the maximum step size for the solution to be stable?
	
\begin{hint}
  You can use the \verb|rkintegrator.hpp| implemented in Problem Sheet 12. See \verb|stabrk_template.cpp|.
\end{hint}
%   
% \begin{hint}
%   \rhc{Give final value for 128 steps as a reference for code validation.}
% \end{hint}

\cprotEnv \begin{solution}
The scheme is of order $3$. With big step sizes the scheme is unstable. At least $64$ steps are needed for the solution to be stable. See \verb|stabrk.cpp|.
\end{solution}
\end{subproblem}
	
\begin{subproblem}[1]
	Calculate the stability function $S(z)$, $z= h\lambda$, $\lambda \in \bbC$ of the method given by the table \eqref{eq:rkesv}.
	
	\cprotEnv \begin{solution}
	We obtain the stability function $S(z)$ by applying our method to the model problem $\dot{y}(t) = \lambda y$, $y(0) = y_0$ and by writing the result in the form $y_1 = S(z)y_0$, where $z:= h\lambda$. For the increment, we obtain
	   \begin{align*}
      k_1 &= \lambda y_0,\\
      k_2 &= \lambda(y_0 + hk_1)\\
      &= \lambda y_0(1 + z),\\
      k_3 &= \lambda(y_0 + \tfrac{h}{4}(k_1 + k_2))\\
      &= \lambda y_0(1 + \tfrac{1}{2}z + \tfrac{1}{4}z^2),
    \end{align*}
		and for the update
		\begin{align*}
      y_1 &= y_0 + \frac{h\lambda y_0}{6}\left(1 + 1 + z + 4\left(1 +
          \frac{1}{2}z +
          \frac{1}{4}z^2\right)\right)\\
      &= y_0\underbrace{\left(1 + z + \frac{1}{2}z^2 +
          \frac{1}{6}z^6\right)}_{=:S(z)}.
    \end{align*}
\end{solution}
	
\end{subproblem}
	
% 	\begin{subproblem}[1]
% 	Complete the \matlab file \texttt{StabDomRK3.m}, which plots the stability domain of the method for $z=x+iy$, $(x,y) \in [-3,3]\times [-3,3]$. Save the plot of the stability domain in the file \texttt{stabdom.eps}
% 	
% 	To what extent does the plot confirm your stability bound $h_{\max}$ from \autoref{sp:stabmaxh}?
% 	
% 	\cprotEnv \begin{solution}
% 	See \autoref{fig:StabDom} for the plot. For the code, see \autoref{code:StabDomRK3}.
% 	
% 	With the parameter value $\lambda = -10$ in \autoref{sp:stabmaxh} we have seen experimentally that the step size must not be larger than $0.25$, thus $|(-10)\dot 0.25| = 2.5$. This is confirmed by our stability domain, from which we read off (for $\lambda \in \bbR$), that $|S(h\lambda)| \overset{!}{\le} 2.5$.
% 	
% 	\begin{figure}[h]
%       \centering
% %       \includegraphics[scale=0.7]{fig/stabdom}
%       \caption{\autoref{sp:stabdom}.}
%       \label{fig:StabDom}
%     \end{figure}
% % 	\lstinputlisting[ 
% % 		emph={}, 
% % 		caption={Implementation of \texttt{StabDomRK3.m}},
% % 		label={code:StabDomRK3}
% % 		]{matlab/StabDomRK3.m}
% \end{solution}
% 	
% \end{subproblem}
% 
% \begin{subproblem}[1]
% Explain why the problem \eqref{eq:StabAWP} is stiff for large negative $\lambda \ll 0$.
% 
% \cprotEnv \begin{solution}
% The solution consists of two parts. For $\lambda \ll 0$, the part $y_0-\sin(t_0)e^{\lambda(t-t_0)}$ decreases rapidly compared to the slowly oscillating $\sin(t)$. Problems with two very different time scales are typically stiff.
% \end{solution}
% 
% \end{subproblem}
% 
% \begin{subproblem}[1]
% Why are explicit method, even if they are consistent, not efficient for stiff problems?
% 
% \cprotEnv \begin{solution}
% Because the fast part of the solution requires impractically many time steps, even if one only wants to compute the slow dynamics.
% \end{solution}
% 
% \end{subproblem}
% 
% \begin{subproblem}[1]
% Prove that the stability function of any explicit Runge-Kutta single step method is a polynomial in $z:= h\lambda$.
% 
% \cprotEnv \begin{solution}
% To prove the claim, we show first by induciton that for any increment $k_i$, $i=1, \dots, s$, we have $hk_i \in P_i(z)$, $z:= h\lambda$.
% 
% For $s=1$, we have
%  \begin{equation*}
%       hk_1 = h\lambda y_0 = zy_0,
%  \end{equation*}
% so $hk_1$ is a polynomial of degree $1$.
% 
% We assume that $hk_N\in P_n(z)$. 
% 
% Then, for $s=n+1$, we have
% \begin{align*}
%       hk_{n+1} &= h\lambda(y_0 + h\sum_{j=1}^{n}a_{n+1,j}k_j) &= z(y_0 + h\sum_{j=1}^{n-1}a_{n+1,j}k_j + ha_{n+1,n}k_n),
% \end{align*}
% from which the induction follows. Furthermore, we see that
% \begin{equation*}
%       y_1 = y_0 + h\sum_{i=1}^sb_ik_i
% \end{equation*}
% is a polynomial of degree $s$, too.
% \end{solution}

\end{problem}
