\begin{problem}[\Matlab{} project: mesh smoothing]

\lref{ex:triagsmooth} introduced you to the concept of a (planar) triangulation 
($\to$ \lref{def:triag}) and demonstrated how the node positions for smoothed
triangulations ($\to$ \lref{def:smoothed}) can be computed by solving sparse
linear systems of equations with system matrices describing the combinatorial
graph Laplacian of the triangulation. 

In this problem we will develop a \matlab{} code for mesh smoothing and refinement
($\to$ \lref{def:regref}) of planar triangulations. Before you start make sure
that you understand the definitions of planar triangulation (\ncsedef{def:triag}), the terminology associated with it, and the notion of a smoothed triangulation (\ncsedef{def:smoothed}).

\begin{subproblem}[1]\label{triag:sp0}
  Learn about \matlab{}'s way of describing triangulations by two vectors and one
  so-called triangle-node incidence matrix from \lref{ex:triagsmooth} or the
  documentation of the \matlab{} function \texttt{triplot}.
\end{subproblem}

\begin{subproblem}[2]\label{triag:sp1}
  (This problem is inspired by the dreary reality of software development, where
  one is regularly confronted with undocumented code written by somebody else who
  is no longer around.)

  \cref{processmesh} lists an uncommented \Matlab{} code, which takes the
  triangle-node incidence matrix of a planar triangulation as input.
  
  Describe in detail what is the purpose of the function \verb|processmesh|
  defined in the file and how exactly this is achieved. Comment the code
  accordingly.
 
 \begin{lstlisting}[style=mcode,label={processmesh},caption={An undocumented
     \matlab{} function extracting some information from a triangulation 
     given in \matlab{} format}]
function [E,Eb] = processmesh(T)
N = max(max(T)); M = size(T,1);
T = sort(T')';
C = [T(:,1) T(:,2); T(:,2) T(:,3); T(:,1) T(:,3)];
% Wow! A creative way to use 'sparse'
A = sparse(C(:,1),C(:,2),ones(3*M,1),N,N);
[I,J] = find(A > 0); E = [I,J];
[I,J] = find(A == 1); Eb = [I,J];
\end{lstlisting}

 \begin{hint}
  Understand what \verb|find| and \verb|sort| do using \matlab{} \texttt{doc}.
 \end{hint}
 
 \begin{hint}
  The \Matlab{} file \verb|meshtest.m| demonstrates how to 
  use the function \verb|processmesh|.
 \end{hint}
 
 \begin{solution}
  See documented code \texttt{processmesh.m}.
 \end{solution}

\end{subproblem}

\begin{subproblem}[3]
\cref{getinfo} displays another undocumented function 
\verb|getinfo|. As arguments it expects the
  triangle-node incidence matrix of a planar triangulation
  (according to \matlab{}'s conventions) and the output
  \texttt{E} of \verb|processmesh|. Describe in detail how the function works.

\begin{lstlisting}[style=mcode,label={getinfo},caption={Another undocumented
    function for extracting specific information from a planar triangulation}]
function ET = getinfo(T,E)
% Another creative us of 'sparse'
L = size(E,1); A = sparse(E(:,1),E(:,2),(1:L)',L,L); 
ET = [];
for tri=T'
  Eloc = full(A(tri,tri)); Eloc = Eloc + Eloc';
  ET = [ET; Eloc([8 7 4])];
end
\end{lstlisting}

 \begin{solution}
  See \texttt{getinfo.m}.
 \end{solution}
\end{subproblem}

\begin{subproblem}[4]
  In \lref{def:regref} you saw the definition of a regular refinement of a
  triangular mesh. Write a \Matlab-function:
 \begin{verbatim}
  function [x_ref, y_ref, T_ref] = refinemesh(x,y,T)
 \end{verbatim}
  that takes as argument the data of a triangulation in \matlab{} format and
  returns the corresponding data for the new, refined mesh.

 \begin{solution}
  See \texttt{refinemesh.m}.
 \end{solution}
\end{subproblem}

\begin{subproblem}[4]
  \lref{eqmv:gl}--\lref{eqmv:extlse} describe the sparse linear system of equations 
  satisfied by the coordinates of the interior nodes of a smoothed triangulation.
  Justify rigorously, why the linear system of equations \lref{eqmv:glplse} always
  has a unique solution. In other words, show that that the part
  $\VA_{\mathrm{int}}$ of the matrix of the combinatorial graph Laplacian
  associated with the interior nodes is invertible for any planar triangulation.
  
  \begin{hint}
    Notice that $\VA_{\mathrm{int}}$ is diagonally dominant ($\to$
    \lref{def:ddom}).
    
    This observation paves the way for using the same arguments as for
    {sub-problem~\ref{ebmm:sp3}}\ of \ref{prb:efficientbandmult}
    You may also appeal to \lref{lem:ddomspd}. 
 \end{hint}

 \begin{solution}
  Consider $\ker \VA_{\mathrm{int}}$. Notice $\vec{A}^{int}$ is (non strictly, i.e. weakly) diagonally dominant. However, since there is at least one boundary node, the solution vector cannot be constant (the boundary node is connected to at least one interior note, for which the corresponding row in the matrix does not sum to $0$). Hence, the matrix is invertible. 
 \end{solution}

\end{subproblem}

\begin{subproblem}[3]
A planar triangulation can always be transformed uniquely to a smooth triangulation under translation of the interior nodes (maintaining the same connectivity) (see the lecture notes and the previous subproblem).

Write a \matlab{}-function
 \begin{verbatim}
  function [xs, ys] = smoothmesh(x,y,T);
 \end{verbatim}
that performs this transformation to the mesh defined by $x,y,T$. Return the column vectors $xs, ys$ with the new position of the nodes.
 
 \begin{hint}
  Use the system of equations in \ncseeq{eqmv:glplse}.
 \end{hint}

 \begin{solution}
  See \texttt{smoothmesh.m}.
 \end{solution}
\end{subproblem}

\end{problem}