\chapter{Sparse Matrix}
\Label{cha:spmat}

\begin{samproblem}*{prb:tripletToCRS}{\cpp{} project: triplet format to CRS format (core problem)}[1]{
  This exercise deals with sparse matrices and their storage in memory. 
	Before beginning, make sure you are prepared on the subject by reading section \cref{sec:sparse} of the lecture notes. 
	In particular, refresh yourself in the various \emph{sparse storage formats} discussed in class (cf. \cref{sec:sparse-matr-stor}). 
	This problem will test your knowledge of algorithms and of advanced C++ features 
	(i.e. structures and  classes\footnote{You may have a look at
    \href{http://www.cplusplus.com/doc/tutorial/classes/}{http://www.cplusplus.com/doc/tutorial/classes/}.}). 
	You do not need to use \eigen{} to solve this problem.
 
  The ultimate goal of this exercise is to devise a function that allows the conversion 
	of a matrix given in \emph{triplet list format} (COO, $\to$ \cref{par:triplet}) 
	to a matrix in \emph{compressed row storage} (CRSm $\to$  \cref{ex:CRS}) format. 
	You do not have to follow the subproblems, provided you can devise a suitable conversion function and suitable data structures for your  matrices.
}

\begin{subproblem}{sp:1}[2]
  In section \cref{par:triplet} you saw how a matrix can be stored in triplet (or coordinate) list format. 
	This format stores a collection of triplets $(i,j,v)$ with $i,j \in \mathbb{N}, i,j \geq 0$ (the indices) and $v \in \mathbb{K}$ (the value at $(i,j)$). 
  Repetitions of $i,j$ are allowed, meaning that the values at the same indices $i,j$ must be \emph{summed} together in the final matrix.
  Define a suitable structure:
	\begin{samcode}[C++-code]{cpp:tripMat_signature}{Function prototype}
  	\begin{lstlisting}[style=cpp]
template <class scalar>
struct TripletMatrix;
  	\end{lstlisting}
	\end{samcode}
  that stores a matrix of type \verb|scalar| in COO format. 
	You can store sizes and indices in \verb|std::size_t| predefined type.
  
  \begin{samhint}
    Store the rows and columns of the matrix inside the structure.
  \end{samhint}
  
  \begin{samhint}
    You can use a \verb|std::vector<your_type>| to store the collection of triplets.
  \end{samhint}
  
  \begin{samhint}
    You can define an auxiliary structure \verb|Triplet| containing the values
    $i,j,v$ (with the appropriate types), but you may also use the type
    \verb|Eigen::Triplet<double>|. 
  \end{samhint}

 % BEGIN ================ SOLUTION  ================   %
  \begin{samwriteprbpart}{solfile}
    \begin{writeverbatim}{prbfile}
      \begin{samsolution}
			\begin{samcode}[C++-code]{cpp:solsp1}{Triplet matrix class}
				\begin{lstlisting}[style=cpp]
template <class scalar>
struct TripletMatrix {
	std::size_t rows, cols; //< Sizes: number of rows and columns
	std::vector<Triplet<scalar>> triplets;
};
				\end{lstlisting}
			\end{samcode}
      \end{samsolution}
    \end{writeverbatim}
  \end{samwriteprbpart}
 % END ================ SOLUTION  ================   %

\end{subproblem}

\begin{subproblem}{sp:2}[2]
  Another format for storing a sparse matrix is the compressed row storage (CRS)
  format (have a look at \cref{ex:CRS}). 

  \textit{Remark}. Here, we are not particularly strict about the ``compressed''
  attribute, meaning that you can store your data in \verb|std::vector|. This may
  ``waste'' some memory, because the \texttt{std::vector} container adds a
  padding at the end of is data that allows for \texttt{push\_back} with
  amortized $O(1)$ complexity.
 
  Devise a suitable structure:
  \begin{samcode}[C++-code]{cpp:crsMat_signature}{Function prototype}
  	 \begin{lstlisting}[style=cpp]
template <class scalar>
struct CRSMatrix;
	 \end{lstlisting}
  \end{samcode}
   holding the data of the matrix in CRS format.
   
  \begin{samhint}
   Store the rows and columns of the matrix inside the structure. To store the data, you can use \verb|std::vector|.
  \end{samhint}
  
  \begin{samhint}
   You can pair the column indices and value in a single structure \verb|ColValPair|. This will become handy later.
  \end{samhint}
  
  \begin{samhint}
   Equivalently to store the array of pointers to the column indices you can use a nested \verb|std::vector< std::vector<your_type> >|.
  \end{samhint}

% BEGIN ================ SOLUTION  ================   %
  \begin{samwriteprbpart}{solfile}
    \begin{writeverbatim}{prbfile}
      \begin{samsolution}
			\begin{samcode}[C++-code]{cpp:solsp2}{CRS matrix class}
				Matrix struct: (you can find the \texttt{ColValPair} struct below)
				\begin{lstlisting}[style=cpp]
//! @brief Defines a matrix stored in CRS format (using ColValPair)
//! The row\_pt contains the data, indexed by row and column position
//! Also stores dimension
//! @tparam scalar is the scalar type of the matrix (e.g. double)
template <class scalar>
struct CRSMatrix {
  std::size_t rows, cols; //< Size of the matrix rows, cols
  // Vector containing, for each row: vector of (col, value) pairs (CRS format)
  std::vector<std::vector<ColValPair<scalar>>> row_pt;
};
				\end{lstlisting}
			The implentation uses the \texttt{ColValPair} struct:.
				\lstincludecpp{./Chapters/SparseMatrix/CPP/tripletToCRS_partialInclusion.cpp}{2}
			\end{samcode}
      \end{samsolution}
    \end{writeverbatim}
  \end{samwriteprbpart}
  % END ================ SOLUTION  ================   %


\end{subproblem}
 
\begin{subproblem}{sp:3}[3]
  Optional: write member functions
	\begin{samcode}[C++-code]{cpp:densify}{Function prototypes}
		\begin{lstlisting}[style=cpp]
Eigen::Matrix<scalar, Eigen::Dynamic, Eigen::Dynamic>
    TripletMatrix<scalar>::densify();
Eigen::Matrix<scalar, Eigen::Dynamic, Eigen::Dynamic>
    CRSMatrix<scalar>::densify();
		\end{lstlisting}
	\end{samcode}
  for the structure \verb|TripletMatrix| and \verb|CRSMatrix| that convert your matrices structures to \eigen{} dense matrices types. This can be helpful in debugging your code.

 % BEGIN ================ SOLUTION  ================   %
  \begin{samwriteprbpart}{solfile}
    \begin{writeverbatim}{prbfile}
      \begin{samsolution}
			\texttt{densify()} for \texttt{TripletMatrix}:
			\begin{samcode}[C++-code]{cpp:solsp3_triplet}{\texttt{densify()} member function for triplet based matrix}
				\lstincludecpp{./Chapters/SparseMatrix/CPP/tripletToCRS_partialInclusion.cpp}{1}
			\end{samcode}
			\texttt{densify()} for \texttt{CRSMatrix}:
			\begin{samcode}[C++-code]{cpp:solsp3_crs}{\texttt{densify()} member function for CRS based matrix}
				\lstincludecpp{./Chapters/SparseMatrix/CPP/tripletToCRS_partialInclusion.cpp}{3}
			\end{samcode}
      \end{samsolution}
    \end{writeverbatim}
  \end{samwriteprbpart}
 % END ================ SOLUTION  ================   %

\end{subproblem}

\begin{subproblem}{sp:4}[5]
  Write a function:
	\begin{samcode}[C++-code]{cpp:tripletToCRS_signature}{Function prototype}
		\begin{lstlisting}[style=cpp]
template <class scalar>
void tripletToCRS(const TripletMatrix<scalar>& T,
		  CRSMatrix<scalar>& C);
		\end{lstlisting}
	\end{samcode}
  that converts a matrix $\vec{T}$ in COO format to a matrix $\vec{C}$ in CRS format. 
	Try to be as efficient as possible.
  
  \begin{samhint}
    The parts of the column indices vector in CRS format that correspond to
    indicdual rows of the matrix must be ordered and without repetitions, whilst
    the triplets in the input may be in arbitrary ordering and with
    repetitions. Take care of those aspects in you function definition.
  \end{samhint}
  
  \begin{samhint}
    If you use a \verb|std::vector| container, have a look at the function
    \href{http://www.cplusplus.com/reference/algorithm/sort/}{\texttt{std::sort}}
    or at the functions
    \href{http://www.cplusplus.com/reference/algorithm/lower_bound/}{\texttt{std::lower\_bound}}
    and
    \href{http://www.cplusplus.com/reference/vector/vector/insert/}{\texttt{std::insert}}
    (both lead to a valid function with different complexities). Look up their
    precise definition and specification in a C++11 reference. 
  \end{samhint}
  
  \begin{samhint}
    You may want to sort a vector containing a structure with multiple values using a particular ordering 
		(i.e. define a custom ordering on your structure and sort according to this ordering). 
		In C++, the standard function \verb|std::sort| provides a way to sort a vector of type \verb|std::vector<your_type>| by defining a \verb|your_type| member operator:
    \begin{lstlisting}[style=cppsimple]
bool your_type::operator<(const your_type& other) const;
		\end{lstlisting}
  	that returns true if \verb|*this| is less than \verb|other| in your particular ordering. Sorting is then performed according to this ordering.
  \end{samhint}

 % BEGIN ================ SOLUTION  ================   %
  \begin{samwriteprbpart}{solfile}
    \begin{writeverbatim}{prbfile}
      \begin{samsolution}
			\begin{samcode}[C++-code]{cpp:solsp4}{converts a triplet based sparse matrix to a CRS based matrix}
			\small
				\lstincludecpp{./Chapters/SparseMatrix/CPP/tripletToCRS_partialInclusion.cpp}{4}
			\end{samcode}
      \end{samsolution}
    \end{writeverbatim}
  \end{samwriteprbpart}
 % END ================ SOLUTION  ================   %


\end{subproblem}

\begin{subproblem}{sp:5}[3]
  What is the worse case complexity of your function (in the number of triplets)?
  
  \begin{samhint}
    Make appropriate assumptions.
  \end{samhint}
  
  \begin{samhint}
   If you use the C++ standard library functions, look at the documentation: there you can find the complexity of basic container operations.
  \end{samhint}
 % BEGIN ================ SOLUTION  ================   %
  \begin{samwriteprbpart}{solfile}
    \begin{writeverbatim}{prbfile}
      \begin{samsolution}
  		In \texttt{tripletToCTS.cpp}, we present two alteratives: pushing back the column/value pairs to an unsorted vector and inserting into a sorted vector at the right position.
  		Let $k$ be the number of triplets. The first method has $k$ \texttt{push\_back} amortized $O(1)$ operations and a	sort of a vector of at most $k$ entries (i.e. $O(k \log k)$ complexity). 
			The second methods inserts $k$ triplets using two $O(k)$  operation, for a complexity of $O(k^2)$.
  		However, if there are many repeated triplets with the same index of if you are adding triplets to an already defined matrix, the second method could prove to be less expensive than the first one.
      \end{samsolution}
    \end{writeverbatim}
  \end{samwriteprbpart}
  % END ================ SOLUTION  ================   %
\end{subproblem}

\begin{subproblem}{sp:5}[1]
  Test the correctness and runtime of your function \verb|tripletToCRS|.
\end{subproblem}

 % BEGIN ================ SOLUTION  ================   %
  \begin{samwriteprbpart}{solfile}
    \begin{writeverbatim}{prbfile}
      \begin{samsolution}
		 	\begin{samcode}[C++-code]{cpp:solsp5}{Timing of the \texttt{tripletToCRS} function}
		 		\lstincludecpp{./Chapters/SparseMatrix/CPP/tripletToCRS_partialInclusion.cpp}{5}
			\end{samcode}	
     \end{samsolution}
    \end{writeverbatim}
  \end{samwriteprbpart}
  % END ================ SOLUTION  ================   %

\end{samproblem}
 
