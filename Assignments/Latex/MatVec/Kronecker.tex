\renewcommand{\ProblemName}{Kronecker}

\begin{samproblem}*
  {prb:Kron}
  {Kronecker product}[1](1)
  {
    In \lref{def:kron} we learned about the so-called Kronecker product.
    In this problem we revisit the
    discussion of \lref{ex:kron}.
  }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% SUBPROBLEM 1: Compute kron
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{subproblem}{subprb:kron-comp}
  Compute the kronecker product
  $\mathbf{C} = \mathbf{A} \otimes \mathbf{B}$ of the matrices
\begin{align*}
  \mathbf{A} = \begin{pmatrix}
         1 & 2   \\
         3 & 4   \\
       \end{pmatrix}
\end{align*}
and
\begin{align*}
\mathbf{B}=\begin{pmatrix}
         5 & 6   \\
         7 & 8   \\
       \end{pmatrix}.
\end{align*}

% ==================== BEGIN SOLUTION
\begin{samwriteprbpart}{cmpm}
  \begin{writeverbatim}{prbfile}
    \begin{samsolution}
      \begin{align*}
\mathbf{X}=\begin{pmatrix}
         5 & 6 & 10 & 12  \\
         7 & 8 & 14 & 16  \\
         15 & 18 & 20 & 24  \\
         21 & 24 & 28 & 32  \\
       \end{pmatrix}.
        \end{align*}
      \end{samsolution}
    \end{writeverbatim}
  \end{samwriteprbpart}
% ==================== END SOLUTION
\end{subproblem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% SUBPROBLEM 3: Implement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{subproblem}{subprb:kron-impl}
Implement a C++ function
\begin{lstlisting}[style=cppsimple]
void kron(const MatrixXd & A, const MatrixXd & B, MatrixXd & C);
\end{lstlisting}
that computes the Kronecker product of the argument matrices
\texttt{A} and \texttt{B} and stores the result in the matrix \texttt{C}.
You can use Eigen block operations, see the \EigenDoc{group__TutorialBlockOperations.html}.

% ==================== BEGIN SOLUTION
\begin{samwriteprbpart}{cmpk}
  \begin{writeverbatim}{prbfile}
    \begin{samsolution}
      \begin{samcode}[C++11-code]{cpp:kron-basic}{Kronecker product}
        \samincludecpp{\codes/MatVec/\ProblemName/solutions/kron.cpp}[1]
        \gitlabSolF{MatVec}{\ProblemName}{kron.cpp}
      \end{samcode}
    \end{samsolution}
  \end{writeverbatim}
\end{samwriteprbpart}
% ==================== END SOLUTION
\end{subproblem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% SUBPROBLEM 2: Complexity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{subproblem}{subprb:kron-cmplx}
What is the asymptotic complexity (\lref{def:comp})
of the C++ code \ref{subprb:Kron_6}? Use the Landau symbol
from \lref{def:O} to state your answer.

% ==================== BEGIN SOLUTION
\begin{samwriteprbpart}{cmpk}
  \begin{writeverbatim}{prbfile}
    \begin{samsolution}
      The code loops two times from $0$ to $n$, i.e. is performing the inner
      poriton of the code $n^2$ times.
      Within the for loop, the
      code is multiplying a $n \times n$ matrix by a scalar, this operation
      has complexity $O(n^2)$.
      In total the complexity is $O(n^2*n^2)=O(n^4)$.
      \end{samsolution}
    \end{writeverbatim}
  \end{samwriteprbpart}
% ==================== END SOLUTION
\end{subproblem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% SUBPROBLEM 3: Implement
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{subproblem}{subprb:kron-impl-vec}
  Devise an efficient implementation of a C++ code for the computation of
  $\mathbf{y} = (\mathbf{A} \otimes \mathbf{B}) \mathbf{x}$.
  \begin{lstlisting}[style=cppsimple]
void kron_mult(const MatrixXd & A, const MatrixXd & B,
               const VectorXd & x, VectorXd & y);
  \end{lstlisting}
  The meaning of the arguments should be self-explanatory.

% ==================== BEGIN SOLUTION
\begin{samwriteprbpart}{cmpk}
  \begin{writeverbatim}{prbfile}
    \begin{samsolution}
      \begin{samcode}[C++11-code]{cpp:kron-vector-mult}{Kronecker product times vector}
        \samincludecpp{\codes/MatVec/\ProblemName/solutions/kron.cpp}[2]
        \gitlabSolF{MatVec}{\ProblemName}{kron.cpp}
      \end{samcode}
    \end{samsolution}
  \end{writeverbatim}
\end{samwriteprbpart}
% ==================== END SOLUTION
\end{subproblem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% SUBPROBLEM 3: Implement one liner problem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{subproblem}{subprb:kron-impl-map}
  Devise an efficient implementation of a C++ code for the computation of
  $\mathbf{y} = (\mathbf{A} \otimes \mathbf{B}) \mathbf{x}$. This time use
  Eigen ``reshaping'' functions.
  \begin{lstlisting}[style=cppsimple]
void kron_reshape(const MatrixXd & A, const MatrixXd & B,
               const VectorXd & x, VectorXd & y);
  \end{lstlisting}
  Study \lref{rem:eigrs} about ``reshaping'' matrices in \eigen{}. See also the
  \EigenDoc{group__TutorialMapClass.html}.

% ==================== BEGIN SOLUTION
\begin{samwriteprbpart}{cmpk}
  \begin{writeverbatim}{prbfile}
    \begin{samsolution}
      \begin{samcode}[C++11-code]{cpp:kron-vector-mult-map}
        {Kronecker product times vector using \texttt{Map()}}
        \samincludecpp{\codes/MatVec/\ProblemName/solutions/kron.cpp}[3]
        \gitlabSolF{MatVec}{\ProblemName}{kron.cpp}
      \end{samcode}
    \end{samsolution}
  \end{writeverbatim}
\end{samwriteprbpart}
% ==================== END SOLUTION
\end{subproblem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% SUBPROBLEM 3: Conmpute runtime
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{subproblem}{subprb:kron:9}
  Compare the runtimes of your implementations in sub-problems
  \ref{subprb:kron-impl}, \ref{subprb:kron-impl-vec} and \ref{subprb:kron-impl-map}.

% ==================== BEGIN SOLUTION
\begin{samwriteprbpart}{cmpk}
  \begin{writeverbatim}{prbfile}
    \begin{samsolution}
      \begin{samcode}[C++11-code]{}{Runtime comparison}
        \samincludecpp{\codes/MatVec/Kronecker/solutions/kron.cpp}[4]
        \gitlabSolF{MatVec}{\ProblemName}{kron.cpp}
      \end{samcode}

      % \samplot{\codes/MatVec/Kronecker/kron_timings_cpp.eps}
              % {fig:kron_timings}
    \end{samsolution}
  \end{writeverbatim}
\end{samwriteprbpart}
% ==================== END SOLUTION
\end{subproblem}

\end{samproblem}
